<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RAEN Guide</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/getting-set-up.html"><strong aria-hidden="true">1.1.</strong> Getting Set Up</a></li></ol></li><li class="chapter-item expanded "><a href="counter/intro.html"><strong aria-hidden="true">2.</strong> Counter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="counter/raen.html"><strong aria-hidden="true">2.1.</strong> Using RAEN</a></li><li class="chapter-item expanded "><a href="counter/updating.html"><strong aria-hidden="true">2.2.</strong> Updating the contract</a></li></ol></li><li class="chapter-item expanded "><a href="status-message/intro.html"><strong aria-hidden="true">3.</strong> Status Message</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="status-message/simple/simple.html"><strong aria-hidden="true">3.1.</strong> Defining the data</a></li><li class="chapter-item expanded "><a href="status-message/simple/methods.html"><strong aria-hidden="true">3.2.</strong> Contract Methods</a></li><li class="chapter-item expanded "><a href="status-message/simple/admin.html"><strong aria-hidden="true">3.3.</strong> Set & Get Status</a></li></ol></li><li class="chapter-item expanded "><a href="status-message/intermediate/addding_message.html"><strong aria-hidden="true">4.</strong> Intermediate Message</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="status-message/intermediate/methods.html"><strong aria-hidden="true">4.1.</strong> Updating Methods</a></li><li class="chapter-item expanded "><a href="status-message/intermediate/admin.html"><strong aria-hidden="true">4.2.</strong> Set & Get Status Part 2</a></li></ol></li><li class="chapter-item expanded "><a href="status-message/advanced/intro.html"><strong aria-hidden="true">5.</strong> Advanced Message</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="status-message/advanced/witgen.html"><strong aria-hidden="true">5.1.</strong> Using witgen</a></li><li class="chapter-item expanded "><a href="status-message/advanced/admin.html"><strong aria-hidden="true">5.2.</strong> Set & Get Status Part 3</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Expert Message</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RAEN Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/raendev/guide/tree/master" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="near--rust-the-friendly-way"><a class="header" href="#near--rust-the-friendly-way">NEAR + Rust, the friendly way</a></h1>
<p>We couldn't find a good intro to both NEAR and Rust.</p>
<p>The <a href="https://doc.rust-lang.org/book/">Rust Book</a> provides a wonderful intro to Rust, the <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)#Adoption">most-loved programming language</a> seven years running.</p>
<p>And some guides, cookbooks, and examples for <a href="https://near.org">NEAR</a> with Rust are scattered here and there.</p>
<p>These are useful. These are fine. Especially the Rust Book. We recommend you read it later.</p>
<p>But none are what we wanted:</p>
<ul>
<li>A quick intro to Rust, providing just enough depth to get you started on your Smart Contract journey;</li>
<li>Examples you can &quot;touch and feel&quot; in the <a href="https://raen.dev/admin">RAEN Admin</a> panel, so you get a quick feedback loop between modifying Rust code and actually using the resulting smart contract;</li>
<li>Progressively more complex examples, so you can see the basics clearly and then build on those patterns.</li>
</ul>
<p>That is, something like <a href="https://raen.dev">RAEN</a> itself, built to help developers launch NEAR apps faster than they thought possible.</p>
<p>So this is less a &quot;guide to RAEN&quot; and more a &quot;guide to NEAR + Rust, the RAEN way.&quot;</p>
<p>You'll be ready to get building faster than you think.</p>
<p>This guide assumes you have experience with the command line and at least one programming language. That's it.</p>
<!--
TODO: link to Status Message: Expert once it's complete

If you have experience with NEAR, you can skip ahead to [Chapter 5: Status Message Expert](./status-message/expert/intro.md).
-->
<h3 id="about-the-name"><a class="header" href="#about-the-name">About the name</a></h3>
<p>&quot;RAEN&quot; is &quot;NEAR&quot; spelled backwards. It is pronounced the same as &quot;rain&quot;.</p>
<h2 id="lets-get-going"><a class="header" href="#lets-get-going">Let's get going!</a></h2>
<p>Ok, if you're still here, you're ready to install some dependencies and look at some examples! Click to the next chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h1>
<ol>
<li>
<p><strong>Install or update Rust:</strong></p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<p>See <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">full instructions in the Rust Book</a>.</p>
</li>
<li>
<p><strong>Add the <a href="https://webassembly.org/">WebAssembly</a> (Wasm) toolchain:</strong> </p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<p>NEAR smart contracts need to be compiled to 32-bit Wasm with <em>architecture</em> and <em>platform</em> both &quot;unknown&quot;.</p>
</li>
<li>
<p><strong>Install RAEN:</strong></p>
<pre><code class="language-bash">cargo install raen
</code></pre>
<p>This will install <code>raen</code> globally, so it doesn't matter where you run it.</p>
<p><code>cargo</code> was installed with Rust. Cargo is <a href="https://doc.rust-lang.org/cargo/index.html">the Rust package manager</a>, like NPM for NodeJS. Rust packages are called <em>crates</em>. <code>raen</code> is a Rust crate.</p>
</li>
<li>
<p><strong>Install <code>near-cli</code>:</strong></p>
<p>Prerequisite: <a href="https://nodejs.dev/learn/how-to-install-nodejs">install NodeJS</a>.</p>
<pre><code class="language-bash">npm install --global near-cli
</code></pre>
<p>There is a Rust version of near-cli <a href="https://github.com/near/near-cli-rs">in the works</a>, but it's not ready yet. Someday <code>raen</code> will wrap <code>near</code> (or work with the new Rust-based CLI as a plugin), allowing you to only install one package. But for now, you need both.</p>
</li>
<li>
<p><strong>Configure your editor:</strong></p>
<p>In Visual Studio Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer extension</a>.</p>
<p>The tools <a href="https://doc.rust-lang.org/book/appendix-04-useful-development-tools.html">recommended by the Rust Book</a> will give you further superpowers, making you feel comfy and productive in no time.</p>
</li>
<li>
<p><strong>Clone the Examples repository:</strong></p>
<pre><code class="language-bash">git clone --depth 1 --branch v0.0.4 https://github.com/raendev/examples.git --recursive raen-examples
</code></pre>
<p>This will clone <a href="https://github.com/raendev/examples">github.com/raendev/examples</a> to a folder called <code>raen-examples</code>.</p>
</li>
<li>
<p><strong>Build with RAEN:</strong></p>
<p>Change into <code>raen-examples/contracts/counter</code>, then build:</p>
<pre><code class="language-bash">raen build --release
</code></pre>
<p>This wraps <code>cargo build --release</code>, adding some extra goodies.</p>
<p>It may take a minute. Rust fetches dependencies and compiles your project in one step. Subsequent runs will go faster.</p>
<p>If you skip this, the editor setup from Step 5 won't work. The help docs shown by your editor are fetched along with the dependencies themselves.</p>
</li>
</ol>
<p>Now you're ready to play with some Rust code. Let's go!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-counter-example"><a class="header" href="#basic-counter-example">Basic Counter Example</a></h1>
<p>At its core, the NEAR blockchain is a big database. A contract is a program with its own storage space, commonly called &quot;contract storage&quot; or &quot;on-chain storage.&quot; You have access to read and write to this storage like you would any key/value data structure.</p>
<p>The simplest example of this is a counter. A contract that can read, increment, and decrement a value.</p>
<p>To follow along, use VS Code to open the <code>contracts/counter</code> folder inside the <code>raen-examples</code> project that you cloned in <a href="counter/../intro/getting-set-up.html">Getting Set Up</a>. Then open <code>src/lib.rs</code>. We'll walk through this code in order.</p>
<h2 id="docs--imports"><a class="header" href="#docs--imports">Docs &amp; Imports</a></h2>
<p>The <code>\\!</code> lines at the top are <a href="https://doc.rust-lang.org/stable/book/ch14-02-publishing-to-crates-io.html#commenting-contained-items">container documentation comments</a> you can use to document a whole contract/module/crate.</p>
<p>The <code>use</code> lines import dependencies, like <code>import</code> or <code>require</code> in JavaScript. Look in <code>Cargo.toml</code> to see that kebab-case crate names like <a href="https://crates.io/crates/near-sdk"><code>near-sdk</code></a> are turned into snake-case names like <code>near_sdk</code> in the code. Let's learn more about these specific imports by seeing how they're used.</p>
<h2 id="state-shape"><a class="header" href="#state-shape">State Shape</a></h2>
<p>Rust's type system gives us a way to tell NEAR's Runtime how our contract's state is shaped. If you're following along, look for the <code>struct</code> definition on line 10:</p>
<pre><code class="language-rust noplayground ignore">pub struct Counter {
    val: i8,
}
</code></pre>
<p>About this:</p>
<table><thead><tr><th>Thing</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>struct</code></td><td>A data structure with fields, similar to a class, object, Hash, or Dictionary in other languages. This <code>struct</code> is named <code>Counter</code>; you could name it whatever you want.</td></tr>
<tr><td><code>val</code></td><td>This is a variable name; you could change it (using the <code>F2</code> key in VS Code) to anything else you want, such as <code>counter</code> or <code>number</code> or <code>num</code>.</td></tr>
<tr><td><code>i8</code></td><td><code>val</code> is of type <code>i8</code>, a signed 8-bit integer. This means it can be between -128 and 127. <br><br>For more on Rust's number types, check out <a href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#integer-types">The Rust Book's description</a>. For more on why <code>i8</code> goes from negative 128 but only to positive 127, search for primers about <a href="https://www.electronics-tutorials.ws/binary/signed-binary-numbers.html">how numbers get stored as binary</a>.</td></tr>
<tr><td><code>pub</code></td><td>Short for <code>public</code>, meaning that the item is visible outside of the file. You need this on the <code>struct</code> you intend to store in contract storage. <br><br>Technically <code>pub</code> is a <a href="https://doc.rust-lang.org/reference/visibility-and-privacy.html">namespace</a>, but that's not important right now.</td></tr>
</tbody></table>
<p>Ok, straightforward enough.</p>
<p>But if you're actually looking at the code in your own editor, you're probably wondering about the stuff right above <code>pub struct Counter</code>:</p>
<pre><code class="language-rust noplayground ignore">#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Counter {
    val: i8,
}
</code></pre>
<p>These are called <a href="https://doc.rust-lang.org/reference/procedural-macros.html">macros</a>. Macros are Rust's way of generating extra code. This kind of &quot;hash bracket&quot; macro (<code>#[...]</code>) will expand the definition of the thing that follows, adding extra logic to save you from needing to copy-paste boilerplate.</p>
<p>(The other kind of Rust macro looks like a function, but has an exclamation mark, like <code>log!(...)</code>. You'll see this soon.)</p>
<p>Here's what these macros are doing:</p>
<table><thead><tr><th>Thing</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>near_bindgen</code></td><td>Generates <a href="https://en.wikipedia.org/wiki/Language_binding">bindings</a> for NEAR. This is how you tell the NEAR Runtime that this is the <code>struct</code> you want to put in contract storage.</td></tr>
<tr><td><code>derive(...)</code></td><td>The <em><a href="https://doc.rust-lang.org/reference/attributes/derive.html"><code>derive</code> attribute</a></em>. Takes a list of <a href="https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"><em>derive macros</em></a>, and generates extra code for each one.</td></tr>
<tr><td><code>Default</code></td><td>Generates a default value for the <code>struct</code>. If you check the rest of the file, you'll see that we never initialize <code>Counter</code> or <code>val</code>. But when you deploy the contract, you'll see that <code>val</code> defaults to <code>0</code>.</td></tr>
<tr><td><code>BorshSerialize</code></td><td>Generates boilerplate for taking your in-memory contract data and turning it into borsh-serialized bytes to store on-disk.</td></tr>
<tr><td><code>BorshDeserialize</code></td><td>Generates boilerplate for reading borsh-serialized, on-disk bytes and turning them into in-memory data structures.</td></tr>
</tbody></table>
<details>
<summary>Expand this section to see the code the above <code>derive</code> macro will generate.</summary>
<pre><code class="language-rust noplayground ignore">impl ::core::default::Default for Counter {
    #[inline]
    fn default() -&gt; Counter {
        Counter {
            val: ::core::default::Default::default(),
        }
    }
}
impl borsh::de::BorshDeserialize for Counter
where
    i8: borsh::BorshDeserialize,
{
    fn deserialize(buf: &amp;mut &amp;[u8]) -&gt; ::core::result::Result&lt;Self, borsh::maybestd::io::Error&gt; {
        Ok(Self {
            val: borsh::BorshDeserialize::deserialize(buf)?,
        })
    }
}
impl borsh::ser::BorshSerialize for Counter
where
    i8: borsh::ser::BorshSerialize,
{
    fn serialize&lt;W: borsh::maybestd::io::Write&gt;(
        &amp;self,
        writer: &amp;mut W,
    ) -&gt; ::core::result::Result&lt;(), borsh::maybestd::io::Error&gt; {
        borsh::BorshSerialize::serialize(&amp;self.val, writer)?;
        Ok(())
    }
}
</code></pre>
</details>
<h2 id="borsh"><a class="header" href="#borsh">Borsh?</a></h2>
<p>The data in your contract and, indeed, your contract itself, need to be stored on-disk in between calls to your contract.</p>
<p>Then when a NEAR user makes a call to your contract, <a href="https://docs.near.org/concepts/basics/validators">validators'</a> computers need to fetch your contract from storage, load it into memory, check how your contract's storage is shaped, then finally deserialize your contract storage and execute the call.</p>
<p><a href="https://borsh.io/">Borsh</a> is a serialization specification (a way of representing data as bytes) developed and maintained by the nearcore team, because nothing else was good enough when NEAR started. The biggest problem with other serialization standards was a lack of consistency—the same in-memory object could be represented in multiple valid ways as bytes.</p>
<p>You'll see Borsh used in a couple different ways in NEAR contracts. The most common is here—as the serialization format for your contract data.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>To attach methods to a <code>struct</code> in Rust, use an <code>impl</code>.</p>
<h3 id="a-view-method"><a class="header" href="#a-view-method">A View Method</a></h3>
<p>Let's start by looking at the view method starting on line 17:</p>
<pre><code class="language-rust noplayground ignore">impl Counter {
    /// Public method: Returns the counter value.
    pub fn get_num(&amp;self) -&gt; i8 {
        self.val
    }
    ...
}
</code></pre>
<table><thead><tr><th>Thing</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>///</code></td><td>In Rust, you can use <code>//</code> for regular comments and <code>///</code> for <a href="https://doc.rust-lang.org/stable/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">documentation comments</a>, which will automatically be turned into documentation by various tooling, including RAEN.</td></tr>
<tr><td><code>fn</code></td><td>The keyword for <code>function</code></td></tr>
<tr><td><code>&amp;self</code></td><td>A reference to the <code>Counter</code> struct. This lets you access the fields on the struct, however, it is <em>immutable</em> meaning that you cannot change or &quot;mutate&quot; the field.<br><br>The ampersand (<code>&amp;</code>) means that the <code>get_num</code> function <em>borrows</em> <code>self</code>, rather than taking <em>ownership</em> of <code>self</code>. To feel confident with Rust, you will need to <a href="https://doc.rust-lang.org/stable/book/ch04-00-understanding-ownership.html">understand borrowing and ownership</a>. For now, pay attention to when this guide uses or omits the ampersand on variable names, and rely on Rust's industry-leading error messages to help you figure out if and when you need an ampersand in your own code.</td></tr>
<tr><td><code>-&gt; i8</code></td><td>The return type of the method. A signed 8-bit integer, matching <code>val</code>.</td></tr>
<tr><td><code>self.val</code></td><td>This accesses the field <code>val</code>. You will also notice that there is no <code>return</code> statement. This is because in Rust everything is an expression, and a function returns the value of the last expression, as long as there is no semicolon after it.</td></tr>
</tbody></table>
<p>Go ahead and play with this a bit. Do things that don't make sense, and your well-configured editor will yell at you. Looking at the errors will teach you about how Rust works. You can try each of these things, changing it back to how it was after each:</p>
<ul>
<li>Change <code>-&gt; i8</code> to <code>-&gt; i16</code></li>
<li>Change <code>-&gt; i8</code> to <code>-&gt; ()</code>, an empty <a href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html#the-tuple-type">tuple</a></li>
<li>Remove <code>-&gt; i18</code> – note that you get the same error message as when you changed it to an empty tuple! Empty tuple is one of the closest things Rust has to a <code>void</code> type.</li>
<li>Change <code>self.val</code> to <code>self.val;</code></li>
<li>Change <code>self.val</code> to <code>return self.val;</code> and it will behave the same way as <code>self.val</code> with no semicolon. Note that this is super non-idiomatic! No one writes Rust this way. Get used to paying attention to the presence &amp; lack of semicolons.</li>
</ul>
<h3 id="a-change-method"><a class="header" href="#a-change-method">A Change Method</a></h3>
<p>Next let's see how to mutate or change <code>val</code>. Look at the <code>increment</code> method starting on line 22:</p>
<pre><code class="language-rust noplayground ignore">impl Counter {
    ...

    /// Public method: Increment the counter.
    pub fn increment(&amp;mut self) -&gt; i8 {
        self.val += 1;
        log!(&quot;Increased number to {}&quot;, self.val);
        self.val
    }
  
    ...
}
</code></pre>
<table><thead><tr><th>Thing</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>;</code></td><td>Rust uses semicolons to separate expressions. See that the last line here is the same as the only line in <code>get_num</code>, with no semicolon. You may have already guessed that this means <code>set_num</code> also returns the value of <code>num</code>. This also matches the return type, <code>-&gt; i8</code>.</td></tr>
<tr><td><nobr><code>&amp;mut self</code></nobr></td><td>Here the reference to the struct is defined as mutable, allowing it to be changed. <br><br>Mutable references are covered in that same chapter of the Rust Book <a href="https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html#mutable-references">on borrowing and ownership</a>.</td></tr>
<tr><td><nobr><code>self.val += 1;</code></nobr></td><td>The same as <code>self.val = self.val + 1</code>. This mutates the <code>Counter</code> struct. Note that the new value will not be saved to contract storage until the method call is over. If you have a bug in the <code>log!</code> line or before the return line, the new value will not actually be persisted.</td></tr>
<tr><td><code>log!</code></td><td>This is a function-like macro, as mentioned above. <code>log!</code> generates code that formats a string and emits a log which you can see in <a href="https://explorer.near.org/">NEAR Explorer</a> or other block-explorer tools.</td></tr>
</tbody></table>
<h2 id="digging-deeper-result-serialization"><a class="header" href="#digging-deeper-result-serialization">Digging Deeper: Result Serialization</a></h2>
<p>Look again at the view function <code>get_num</code>. It returns an <code>i8</code>. However, any call to a NEAR contract happens via <a href="https://docs.near.org/docs/api/overview#rpc-api">Remote Procedure Calls</a>, and this <code>i8</code> needs to be serialized into something the consumer can read. By default, <code>near_bindgen</code> generates code to serialize it into a JSON number, since this is the most common case, e.g. a web app calling <code>get_num</code>. If you really need to, you can override this setting. For example, this would serialize it to Borsh instead:</p>
<pre><code class="language-rust noplayground ignore">#[result_serializer(borsh)]
pub fn get_num(&amp;self) -&gt; i8 {
    self.val
}
</code></pre>
<p>Serializing to Borsh can be useful in a couple cases:</p>
<ul>
<li><a href="https://docs.near.org/docs/concepts/gas">gas</a>-intensive contract methods that need to optimize every detail</li>
<li>methods only used in <a href="https://docs.near.org/docs/tutorials/contracts/cross-contract-calls">cross-contract call</a> logic, where no external consumers are expected or allowed</li>
</ul>
<p>However, most of the time you will probably want to stick with the default JSON result serialization, to make it easier for apps to interact with your contract.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this unit we saw our first NEAR smart contract. We were introduced to some Rust basics, like its type system, numbers, <code>struct</code>, documentation comments, and (im)mutability. We saw how NEAR works with Rust to generate code for you using <em>macros</em>, leaving your code clean and focused on your own logic, rather than various boilerplate.</p>
<p>Next, we'll build the contract with <code>raen</code> and interact with it using RAEN Admin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-raen"><a class="header" href="#using-raen">Using RAEN</a></h1>
<p>Now let's use RAEN to build the contract.</p>
<p>From within the <code>counter</code> directory run the build command:</p>
<pre><code class="language-bash">raen build --release
</code></pre>
<p>This does a few things:</p>
<ol>
<li>
<p>Runs <a href="https://doc.rust-lang.org/stable/book/ch01-03-hello-cargo.html"><code>cargo build</code></a> in a smart way:</p>
<ul>
<li>Passes along relevant flags, such as <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#release"><code>--release</code></a></li>
<li>Adds essential NEAR flags, such as <code>--target wasm32-unknown-unknown</code>.</li>
</ul>
<p>This creates a Wasm file at <code>./target/wasm32-unknown-unknown/target/counter.wasm</code></p>
</li>
<li>
<p>Uses <a href="https://github.com/AhaLabs/witme">witme</a> to inspect the contract's Rust code and generates <a href="https://github.com/bytecodealliance/wit-bindgen">Wit</a> from it. Wit is a an emerging standard for describing the interfaces of Wasm binaries, on track to eventually merge with Wasm itself.</p>
</li>
<li>
<p>Creates a new Wasm file copied from the one generated in Step 1, injecting the Wit into a <a href="https://webassembly.github.io/spec/core/appendix/custom.html">Custom Section</a>.</p>
</li>
<li>
<p>Compresses this new Wasm file and saves it to <code>./target/res/counter.wasm</code>. This compression makes the final result smaller than contracts built without RAEN, even with the Wit added. That's a good thing! Blockchains are space-constrained, and you'll need to pay for <a href="https://docs.near.org/docs/concepts/storage-staking">storage costs</a>.</p>
</li>
</ol>
<p>The TL;DR is that <code>raen build</code> is a fast, safe way to build your smart contracts, and it adds interface types to your contract which can then be used by other tooling, such as RAEN Admin.</p>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p>As mentioned in <a href="counter/../intro/getting-set-up.html">Getting Set Up</a>, <code>raen</code> will eventually wrap <code>near-cli</code>. But for now, you need the <code>near</code> command to deploy:</p>
<pre><code class="language-bash">near dev-deploy ./target/res/counter_contract.wasm
</code></pre>
<p>This will create a new throwaway NEAR account on testnet and deploy the contract to that address.</p>
<p>If you're using a bash-compatible shell such as <code>zsh</code>, you can use <a href="https://hyperpolyglot.org/unix-shells#cmd-subst-note">command substitution</a> to <code>build</code> &amp; <code>dev-deploy</code> in one step:</p>
<pre><code class="language-bash">near dev-deploy $(raen build --release -q)
</code></pre>
<p>Note that this adds a <code>-q</code> flag to <code>raen build</code>, making it <em>quiet</em>. This means it only outputs the location of the built file.</p>
<p>Copy the contract address mentioned by the <code>dev-deploy</code> output; it will look something like <code>dev-1234-1234</code> but longer. Now head over to <a href="https://raen.dev/admin">raen.dev/admin</a> and paste that address into the big box.</p>
<p>Like a good cooking show, a fully-cooked contract has already been deployed. If you're not following along with your own code, you can use RAEN Admin to investigate <a href="https://raen.dev/admin/#/counter.raendev.testnet"><code>counter.raendev.testnet</code></a>.</p>
<h2 id="raen-admin"><a class="header" href="#raen-admin">RAEN Admin</a></h2>
<p>Now that your RAEN-built contract provides interface information, <a href="https://raen.dev/admin">RAEN Admin</a> can use it to generate a complete interactive form.</p>
<h3 id="view-methods"><a class="header" href="#view-methods">View Methods</a></h3>
<p>First, notice on the top left that you have a login button and a list of view methods</p>
<p><img src="counter/images/view.png" alt="View Methods" /></p>
<p>Clicking on <a href="https://raen.dev/admin/#/counter.raendev.testnet/GetNum"><code>get_num</code></a> will immediately call the view method since it has no arguments.</p>
<p>You can also see that the comment from the code is displayed, helping to describe the method.</p>
<p><img src="counter/images/get_num.png" alt="Get Num" /></p>
<h3 id="change-methods"><a class="header" href="#change-methods">Change Methods</a></h3>
<p>Below View Methods, you'll see Change Methods.</p>
<p><img src="counter/images/change.png" alt="Change Calls" /></p>
<p>Let's pick <a href="https://raen.dev/admin/#/counter.raendev.testnet/Increment"><code>increment</code></a>.</p>
<p><img src="counter/images/increment.png" alt="increment" /></p>
<p>Again you can see the comments from the code. However, now there are two new fields in the form. </p>
<ul>
<li><code>attachedDeposit</code> is how much near you want to attach to the transaction; it is in <a href="https://en.wikipedia.org/wiki/Yocto-">yocto</a>Near, which is the smallest unit of NEAR (<code>1N = 1000000000000000000000000 yN</code> or <code>10^24</code>).</li>
<li><code>gas</code> is how much gas to attach to cover the execution costs. It is in <a href="https://docs.near.org/docs/concepts/gas">units of gas</a>, here 30 <a href="https://en.wikipedia.org/wiki/Tera-">Tera</a>Gas—more than enough for this transaction.</li>
</ul>
<p>You will need to sign in to submit this form. If you don't have a NEAR <a href="https://docs.near.org/docs/concepts/networks#testnet">testnet</a> account, NEAR Wallet will guide you through creating one.</p>
<p>Once you sign in and submit the <code>increment</code> form, you can revisit <a href="https://raen.dev/admin/#/counter.raendev.testnet/GetNum"><code>get_num</code></a> and see that it is now <code>1</code> (or probably something else, if you're using <code>counter.raendev.testnet</code>).</p>
<h2 id="digging-deeper-look-no-near-wallet-confirmation"><a class="header" href="#digging-deeper-look-no-near-wallet-confirmation">Digging deeper: look, no NEAR Wallet confirmation</a></h2>
<p>If you're used to Ethereum apps, you may be surprised that submitting the <code>increment</code> form didn't require any confirmation to spend your testnet NEAR tokens on transaction fees.</p>
<p>NEAR prioritizes both developer and user experience. One way it accomplishes good user experience: <a href="https://docs.near.org/docs/concepts/gas">negligible and predictable transaction fees</a>, also called <em>gas</em> fees. And then, if gas fees are negligible for most transactions, why bother requiring user confirmation over and over and over?</p>
<p>Here is what actually happens when you sign in with NEAR:</p>
<ul>
<li>
<p>NEAR Wallet adds a new <a href="https://docs.near.org/docs/concepts/access-keys">FunctionCall Access Key</a> to your account. You can see this listed in the &quot;Recent activity&quot; section on <a href="https://wallet.testnet.near.org">wallet.testnet.near.org</a>. In a nutshell:</p>
<ul>
<li>This key can ONLY make calls to the <code>counter.raendev.testnet</code> contract (or your version of it)</li>
<li>This key has an allowance of <strong>0.25 NEAR</strong> that it can spend on transaction fees on your behalf. If you use RAEN Admin for long enough to exhaust this allowance, every call to a Change Method will start redirecting to NEAR Wallet.</li>
<li>If a transaction has an <code>attachedDeposit</code>, no matter how small, it WILL require explicit user confirmation.</li>
</ul>
</li>
<li>
<p>NEAR Wallet redirects to the previous URL at <code>raen.dev/admin</code>, adding some extra URL parameters with information about this new Access Key.</p>
</li>
<li>
<p><code>raen.dev/admin</code>, using default behavior in <a href="https://docs.near.org/docs/api/javascript-library">near-api-js</a>, adds this key to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage">localStorage</a> in your browser. If you know your way around your browser's <a href="https://developer.chrome.com/docs/devtools/storage/localstorage/">Web Inspector</a>, you can use it to see your key (be careful! this is a private key! but also it can only call <code>counter.raendev.testnet</code> and can only spend 0.25 NEAR, so maybe you don't need to be <em>too</em> careful).</p>
</li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Congratulations! You deployed your first NEAR smart contract. And since you built it with <code>raen</code>, you were able to interact with your contract using RAEN Admin. This required creating your first NEAR testnet account, which taught you a little bit about NEAR's account system. Named accounts! Multiple access keys for each account! Great UX that doesn't require confirming every negligible transaction.</p>
<p>Now let's investigate a bug in this contract, and learn how to fix it and deploy an updated version of the contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-the-contract"><a class="header" href="#updating-the-contract">Updating the contract</a></h1>
<p>Without <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overflow-checks">overflow checks</a> enabled, if <code>val</code> is currently <code>127</code>, the next time it is incremented it will <em>overflow</em>, wrapping around to be <code>-128</code>. Likewise, it can <em>underflow</em> if currently <code>-128</code> and you decrement.</p>
<p>This would obviously be <strong>very bad news</strong> if you were building your own smart-contract-based currency!</p>
<p>Let's see if we can make <code>val</code> overflow. And then let's see how to prevent this.</p>
<h2 id="method-1-mash-increment-128-times"><a class="header" href="#method-1-mash-increment-128-times">Method 1: mash <code>increment</code> 128 times</a></h2>
<p>With the existing contract, you could use the RAEN Admin panel and mash the Submit button on the <code>increment</code> form 128 times.</p>
<p>This could take a while, though! Let's see if we can improve the code to make it easier.</p>
<h2 id="method-2-new-default"><a class="header" href="#method-2-new-default">Method 2: new <code>default</code></a></h2>
<p>If you're following along with your own contract, you can change the default value of <code>val</code> to start at <code>127</code> rather than <code>0</code>. This is a good way to learn about where the default of <code>0</code> currently comes from.</p>
<p>If you get stuck while following along, you can see this method and the following all implemented on <a href="https://github.com/raendev/examples/pull/4/files">this branch</a>.</p>
<p>Above <code>pub struct Counter</code>, change the <code>derive</code> macro by removing the <code>Default</code> trait:</p>
<pre><code class="language-diff">-#[derive(Default, BorshDeserialize, BorshSerialize)]
+#[derive(BorshDeserialize, BorshSerialize)]
</code></pre>
<p>Now, below the closing bracket of <code>pub struct Counter</code>, you can implement <code>default</code> manually:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Counter {
    val: i8,
}

impl Default for Counter {
    fn default() -&gt; Self {
        Self { val: 127 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="if-youre-following-along"><a class="header" href="#if-youre-following-along">If you're following along</a></h3>
<p>Build and re-deploy to see the new default:</p>
<pre><code class="language-bash">near dev-deploy $(raen build --release -q)
</code></pre>
<p>Refresh your browser page to load in the updated contract. Check <code>get_num</code>.</p>
<p>But oh no, if you've already incremented or decremented the number, you'll see that this made no change. Which is what you'd expect! It only changes the <em>default</em>. That is, the value that is shown if you didn't actually change it and store the new value.</p>
<p>To see this default in action, you can delete the <code>neardev</code> folder and run the <code>dev-deploy</code> command again. This will create a brand new NEAR testnet account before deploying your contract. You'll need to copy the new <code>dev-1234-1234</code> address it gives you and paste it into RAEN Admin.</p>
<p>Now when you check <code>get_num</code>, you'll see the number you set as a default! Call <code>increment</code> (you'll need to sign in again, since this is a new contract) and watch it overflow.</p>
<h3 id="if-youre-not"><a class="header" href="#if-youre-not">If you're not</a></h3>
<p>The contract deployed at <a href="https://raen.dev/admin/#/counter.raendev.testnet">counter.raendev.testnet</a> already has a value for <code>val</code> saved to contract storage. It will not make use of a new default.</p>
<p>Let's try a different way.</p>
<h2 id="method-3-new-set_num"><a class="header" href="#method-3-new-set_num">Method 3: new <code>set_num</code></a></h2>
<p>See if you can write your own <code>set_num</code> method based on the code for <code>increment</code> and <code>decrement</code> in the contract. If you need a hint, <a href="https://github.com/raendev/examples/pull/4/files">here's what it looks like</a>.</p>
<h3 id="if-youre-following-along-1"><a class="header" href="#if-youre-following-along-1">If you're following along</a></h3>
<p>Save your file with new <code>set_num</code>, then build and re-deploy:</p>
<pre><code class="language-bash">near dev-deploy $(raen build --release -q)
</code></pre>
<p>Unlike Method 2, you don't need to create a new testnet account. Just refresh the RAEN Admin panel and see the <code>set_num</code> method appear under Change Methods. Go ahead and try it out!</p>
<h3 id="if-youre-not-1"><a class="header" href="#if-youre-not-1">If you're not</a></h3>
<p>The <a href="https://github.com/raendev/examples/pull/4/files">reference code</a> has been deployed to <a href="https://raen.dev/admin/#/v2.counter.raendev.testnet">v2.counter.raendev.testnet</a> for you to play with.</p>
<p>Note that this code already fixed the overflow issue. If you want to see the overflow in action, you'll have to follow along with your own code.</p>
<h2 id="fixing-that-overflow"><a class="header" href="#fixing-that-overflow">Fixing that overflow</a></h2>
<p>Now you can call <code>increment</code> and see that the number goes from <code>127</code> to <code>-128</code>. Oops! How do we fix it?</p>
<p>Open up the <code>Cargo.toml</code> file. <a href="https://doc.rust-lang.org/cargo/guide/cargo-toml-vs-cargo-lock.html">Cargo.toml</a> is to Rust what <code>package.json</code> is to NodeJS. You'll see sections for <code>dependencies</code> and <code>dev-dependencies</code> and more generic information about this package/contract/crate.</p>
<p>See those lines with <code>overflow-checks = false</code>? Change them to <code>overflow-checks = true</code>. Now rebuild and redeploy:</p>
<pre><code class="language-bash">near dev-deploy $(raen build --release -q)
</code></pre>
<p>You'll see that this takes longer to build than when you make changes to your contract itself. Rust needs to recompile all of your dependencies using the new setting.</p>
<p>Refresh your admin panel, set the number back to <code>127</code>, and call <code>increment</code>. You'll see an error message. This means the contract panicked rather than allowing the integer overflow. It worked!</p>
<h2 id="digging-deeper-wait-arent-blockchains-immutable"><a class="header" href="#digging-deeper-wait-arent-blockchains-immutable">Digging Deeper: wait, aren't blockchains immutable?</a></h2>
<p>You may have heard that blockchains are <em>immutable</em>, that they provide permanent ledgers of all on-chain activity.</p>
<p>How does this fit with the fact that you just upgraded a smart contract, and it was actually super easy? It's even called a <em>contract</em>—doesn't that imply that it should be hard to change? If it's so easy for a contract owner to alter the contract, how can anyone using it trust they won't be scammed?</p>
<p>Great questions!</p>
<p>On other blockchains, it is in fact very difficult to upgrade a contract. They work around this with proxy contracts and other patterns.</p>
<p>But NEAR has that handy account system, where each account has multiple keys. We already learned about <em>Function Call Access Keys</em> in the last unit; that's what makes it safe to have a web-based wallet, with web apps that store a private key in local storage.</p>
<p>The other kind of key is a <em>Full Access</em> key. When you run <code>dev-deploy</code>, you get a Full Access key to a brand new testnet account. If you have a Full Access key, you can do anything with that account. Deploy or remove a contract, call other contracts, send tokens, create sub-accounts, even delete the account.</p>
<p>(Note that even all of these actions are stored on the permanent blockchain ledger! If you're running or know the address of an <a href="https://near-nodes.io/archival/run-archival-node-without-nearup">archival node</a>, you can query the state of a given account at a given block/second in time, even if the contract on that account has changed or the account has been completely deleted. If you're querying a regular non-archival node, it will probably only keep about two days of history.)</p>
<p>In the early days of launching and testing a smart contract, it's nice to be able to leave the contract in &quot;trusted mode,&quot; keeping Full Access keys around so you can iterate quickly. But if you want people to trust your contract with large investments, you'll want to get a security review from a reputable company, and those companies will want to make sure you don't have any Full Access keys still on the contract (you can get a list of all keys on any NEAR account with <code>near keys</code> in your command line), and that you didn't build in any sneaky ways to add new Full Access keys given only a Function Call key.</p>
<p>(Note that there still patterns that allow you to upgrade such a contract, such as <a href="https://www.near-sdk.io/upgrading/via-dao-vote">requiring a review board to vote on proposed upgrades</a>.)</p>
<p>If you're <em>using</em> a smart contract, especially if you're considering trusting it with significant assets, you should check that it had a security review first!</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Over this whole Counter chapter, we saw our first Rust code: a simple NEAR smart contract that implements a counter. Anyone can call <code>get_num</code> to see the current value, and anyone can change the number, too!</p>
<p>In this unit we learned about integer overflows, and played with them by updating our code to change the default value and add a new change method. We saw that we only need to refresh the RAEN Admin page to see the latest changes. We fixed the integer overflow bug by changing <code>Cargo.toml</code> settings. And we also learned about blockchain immutability and Full Access keys.</p>
<p>Overall, this Counter was a good way to learn some Rust and NEAR basics, but pretty silly as a real contract. Next, let's take a look at an example that does something more useful, storing different information for every user who calls the contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-status-message-contract"><a class="header" href="#basic-status-message-contract">Basic Status Message Contract</a></h1>
<p>Previously the contract had state that was shared by any account that can call the contract. Next we will show how each account can get its own state within the contract.</p>
<h2 id="signer-account"><a class="header" href="#signer-account">Signer Account</a></h2>
<p>All change calls need to be signed by an account, this proves that no other account made the transaction. From the contract's perspective, when executing it has access to the current context which includes the <code>signer</code> account id.</p>
<p>Since this account id is unique to the signer it can be used as a key in storage. Let's take a look.</p>
<h3 id="env-accountid-and-lookupmap"><a class="header" href="#env-accountid-and-lookupmap"><code>env</code>, <code>AccountId</code>, and <code>LookupMap</code></a></h3>
<pre><code class="language-rust noplayground ignore">use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::LookupMap,
    env, near_bindgen, AccountId,
};

</code></pre>
<p><code>env</code> provides functions for interacting with the NEAR blockchain. This includes <code>env::signer_account_id()</code>, which as you expect returns the account id of the signer.</p>
<p><code>AccountId</code> is a wrapper type around <code>String</code>. Using it ensures that you won't use a malformed account id.</p>
<p><code>LookupMap</code> is our first experience with a persistent data structure. You can think of them like corresponding data structures that have their data in storage. In this case <code>LookupMap</code> is like a <code>HashMap</code>, but the keys are contract storage keys and values are written to storage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-state"><a class="header" href="#contract-state">Contract State</a></h1>
<p>Let's take a look at the struct that defines the contract:</p>
<pre><code class="language-rust noplayground ignore">#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct StatusMessage {
    records: LookupMap&lt;AccountId, String&gt;,
}
</code></pre>
<p>This struct has one field <code>records</code>; a <code>LookupMap</code> that maps <code>AccountId</code>s to <code>String</code>s.</p>
<p>You will also notice that this contract doesn't implement <code>Default</code>. This is because we are going to implement it ourselves!</p>
<pre><code class="language-rust noplayground ignore">impl Default for StatusMessage {
    fn default() -&gt; Self {
        Self {
            records: LookupMap::new(b&quot;r&quot;),
        }
    }
}
</code></pre>
<p>This is how you create an implementation that fulfills a trait. In this case there is one function, <code>default</code>, which returns <code>Self</code>, which is a shorthand for the type implementing the trait, in this case <code>StatusMessage</code>.</p>
<p>When the contract executions it first loads the contract's state from storage. If no state exists it calls <code>StatusMessage::default()</code> to get the initial instance.</p>
<h1 id="new"><a class="header" href="#new"><code>new</code></a></h1>
<p>You might be familiar with constructors in other languages. Rust has no concept of a constructor, but it is common to have a function called <code>new</code> to create an instance of a type.</p>
<p>In this case, <code>LookupMap::new(b&quot;r&quot;)</code> creates a new <code>LookupMap</code>. <code>b&quot;r&quot;</code> is byte representation of the string <code>&quot;r&quot;</code>, which is used as a prefix before any keys. For example, <code>eve.testnet</code> --&gt; <code>reve.testnet</code>.  This creates a namespace for this data structure as long as this prefix is unique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-methods"><a class="header" href="#contract-methods">Contract Methods</a></h1>
<p>In this case we will just have two methods, <code>set_status</code> and <code>get_status</code>.</p>
<h2 id="set_status"><a class="header" href="#set_status"><code>set_status</code></a></h2>
<pre><code class="language-rust noplayground ignore">    pub fn set_status(&amp;mut self, message: String) {
        let account_id = env::signer_account_id();
        self.records.insert(&amp;account_id, &amp;message);
    }
</code></pre>
<p>Unlike the counter this method takes an argument, <code>meassage</code> which is a <code>String</code>. This message is then inserted into the map, which writes it to storage. You'll notice a <code>&amp;</code>, <a href="status-message/simple/../../counter/impl.html#self">which learned about in the previous chapter</a>, this is how we pass a reference to <code>insert</code>, which will then be able to read the <code>String</code> to write it to storage.</p>
<h2 id="get_status"><a class="header" href="#get_status"><code>get_status</code></a></h2>
<pre><code class="language-rust noplayground ignore">    pub fn get_status(&amp;self, account_id: String) -&gt; Option&lt;String&gt; {
        self.records.get(&amp;account_id.parse().unwrap())
    }
</code></pre>
<p>Here is our first example of an <code>Option</code> type. An Option is other some value or nothing, <code>Option::Some(value), Option::None</code>. This is the same as <code>null</code> in other languages. <code>records.get</code> will return <code>None</code> if the account was not in the map. This function will then return <code>None</code>.</p>
<p>We also need to convert the string <code>account_id</code> to an <code>AccountId</code>. There is a <code>parse</code> method, which returns will potentially fail if the <code>account_id</code> is invalid. In rust this is a <code>Result</code>, which either has a value or an error. <code>unwrap</code> let's us access the value and will panic and exit if there was an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-a-blank-status"><a class="header" href="#getting-a-blank-status">Getting a blank status</a></h1>
<p>Let's return to the admin panel this time for <code>simple.statusmessage.raendev.testnet</code>.</p>
<p>First, let's try getting the status message for an account that definitely won't have one.  We should get back <code>null</code>, JavaScript's version of <code>Option::None</code>. This</p>
<p>Use the following link:</p>
<p><a href="https://raen.dev/admin/#/simple.statusmessage.raendev.testnet/GetStatus?data=%257B%2522args%2522%253A%257B%2522account_id%2522%253A%2522aa%2522%257D%257D"><code>raen.dev/admin/#/simple.statusmessage.raendev.testnet/GetStatus?data=%257B%2522args%2522%253A%257B%2522account_id%2522%253A%2522aa%2522%257D%257D</code></a></p>
<p>You'll notice that the link has some extra args at the end. This is the form data that will automatically fill in the form and since this is a view method it execute the call immediately.</p>
<h2 id="setting-a-status"><a class="header" href="#setting-a-status">Setting a status</a></h2>
<p><a href="https://raen.dev/admin/#/simple.statusmessage.raendev.testnet/SetStatus"><code>raen.dev/admin/#/simple.statusmessage.raendev.testnet/SetStatus</code></a></p>
<p>Next, return to <a href="https://raen.dev/admin/#/simple.statusmessage.raendev.testnet/GetStatus"><code>get_status</code></a>, but this time with your own testnet account.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-a-new-message-struct"><a class="header" href="#adding-a-new-message-struct">Adding a new <code>Message</code> struct</a></h1>
<p>We just say how to make a message that was a <code>String</code>, but that is a little boring. Let's make a <code>Message</code> with a body and a title.</p>
<pre><code class="language-rust noplayground ignore">pub struct Message {
    title: String,
    body: String,
}
</code></pre>
<p>Next we need to update contract's state struct.</p>
<pre><code class="language-rust noplayground ignore">pub struct StatusMessage {
    records: LookupMap&lt;AccountId, Message&gt;,
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updating-the-methods"><a class="header" href="#updating-the-methods">Updating the Methods</a></h1>
<p>Now we need to update our methods so that we can pass two <code>String</code>s instead of just one.</p>
<h2 id="set_status-1"><a class="header" href="#set_status-1"><code>set_status</code></a></h2>
<pre><code class="language-rust noplayground ignore">    pub fn set_status(&amp;mut self, title: String, body: String) {
        let account_id = env::signer_account_id();
        self.records.insert(&amp;account_id, &amp;Message { title, body });
    }
</code></pre>
<p>One thing to note is <code>Message { title, body }</code>, this is how you can directly create a message without using a <code>new</code> function like we saw earlier.</p>
<h2 id="get_status-1"><a class="header" href="#get_status-1"><code>get_status</code></a></h2>
<pre><code class="language-rust noplayground ignore">    pub fn get_status(&amp;self, account_id: AccountId) -&gt; Option&lt;String&gt; {
        self.records
            .get(&amp;account_id)
            .map(|Message { body, title }| format!(r#&quot;{{&quot;body&quot;:&quot;{body}&quot;, &quot;title&quot;: &quot;{title}&quot;}}&quot;#))
    }
</code></pre>
<p>Before <code>account_id</code> was a <code>String</code>, but now we can use <code>AccountId</code> directly which will panic the contract if the account id is not valid.</p>
<p>Next we have a new function <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map">map</a>, which is a method <code>Option</code>. And a new syntax <code>|Message { body, title}|</code>. </p>
<p><code>map</code> is a function takes a function as argument. Then if the Option is not <code>None</code> it will pass the inner value to the function. In Rust an anonymous rust has the following syntax, <code>|x| x + 1</code>, if you are familiar with JavaScript it is like an arrow function <code>(x) =&gt; x + 1</code>.</p>
<p>Rust let's you ~destructure~ the argument passed to the function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|Message { body, title }| format!(r#&quot;{{&quot;body&quot;:&quot;{body}&quot;, &quot;title&quot;: &quot;{title}&quot;}}&quot;#))

// Is the same as the function
|msg| {
  let body = msg.body;
  let title = msg.title;
  format!(r#&quot;{{&quot;body&quot;:&quot;{body}&quot;, &quot;title&quot;: &quot;{title}&quot;}}&quot;#)
})
<span class="boring">}
</span></code></pre></pre>
<p>Lastly, we are creating a String that represents the JSON representation of <code>Message</code>, later we won't have to do this by hand.</p>
<p><code>format!</code> is a macro for injecting strings into another in this case <code>{body}</code> and <code>{title}</code> are replaced by the corresponding variables.</p>
<p><code>r#&quot;..&quot;#</code> is called a raw string, which let's us use a <code>&quot;</code> from within the string. And we need two <code>{{</code> and <code>}}</code> so that <code>format!</code> understands that it's actually a <code>{</code> or <code>}</code> in the <code>String</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="admin-round-two"><a class="header" href="#admin-round-two">Admin Round Two</a></h1>
<p>Let's return to the admin panel this time for <code>intermediate.statusmessage.raendev.testnet</code>.</p>
<h2 id="setting-a-status-1"><a class="header" href="#setting-a-status-1">Setting a status</a></h2>
<p>Now there will two input boxes in the form:</p>
<p><a href="https://raen.dev/admin/#/intermediate.statusmessage.raendev.testnet/SetStatus"><code>raen.dev/admin/#/intermediate.statusmessage.raendev.testnet/SetStatus</code></a></p>
<h2 id="get-status-message"><a class="header" href="#get-status-message">Get Status Message</a></h2>
<p>Here is an example for eve.testnet:</p>
<p><a href="https://raen.dev/admin/#/intermediate.statusmessage.raendev.testnet/GetStatus?data=%257B%2522args%2522%253A%257B%2522account_id%2522%253A%2522eve.testnet%2522%257D%257D">https://raen.dev/admin/#/intermediate.statusmessage.raendev.testnet/GetStatus?data=%257B%2522args%2522%253A%257B%2522account_id%2522%253A%2522eve.testnet%2522%257D%257D</a></p>
<p>Now the status should return a <code>String</code> of the JSON like</p>
<pre><code class="language-json">&quot;{\&quot;title\&quot;: \&quot;hello\&quot;, \&quot;body\&quot;: \&quot;world\&quot;}&quot;
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p>Now let's take this a step further and use <code>Message</code> directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-message"><a class="header" href="#advanced-message">Advanced Message</a></h1>
<p>Having to pass two arguments to create the Message is annoying, why not pass the Message directly!</p>
<p>First let's add some documentation to the struct:</p>
<pre><code class="language-rust noplayground ignore">/// A simple message with a title
#[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
#[serde(crate = &quot;near_sdk::serde&quot;)]
#[witgen]
pub struct Message {
    /// Title that describes the message
    title: String,
    /// body of the  message
    body: String,
}
</code></pre>
<p><code>Deserialize</code> and <code>Serialize</code> are now needed to allow the <code>Message</code> to be parsed to and from JSON.</p>
<h2 id="update-methods"><a class="header" href="#update-methods">Update methods</a></h2>
<pre><code class="language-rust noplayground ignore">#[near_bindgen]
impl StatusMessage {
    pub fn set_status(&amp;mut self, message: Message) {
        let account_id = env::signer_account_id();
        self.records.insert(&amp;account_id, &amp;message);
    }

    pub fn get_status(&amp;self, account_id: AccountId) -&gt; Option&lt;Message&gt; {
        self.records.get(&amp;account_id)
    }
}
</code></pre>
<p>Now we have <code>Message</code> as a argument to <code>set_status</code> and don't need to convert <code>Message</code> manually when returning it from <code>get_status</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witgen"><a class="header" href="#witgen"><code>witgen</code></a></h1>
<p>We just breezed by the following line:</p>
<pre><code class="language-rust noplayground ignore">#[witgen]
</code></pre>
<p><code>witgen</code> is a special macro needed generate a type definition for user made types like <code>Message</code>.</p>
<p>We also skipped the line that imported the macro:</p>
<pre><code class="language-rust noplayground ignore">use witgen::witgen;
</code></pre>
<p>The <a href="https://github.com/bnjjj/witgen">witgen</a> crate is</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="admin-round-three"><a class="header" href="#admin-round-three">Admin Round Three</a></h1>
<p>Let's return to setting a message and see what's different.</p>
<p><a href="https://raen.dev/admin/#/advanced.statusmessage.raendev.testnet/SetStatus"><code>raen.dev/admin/#/advanced.statusmessage.raendev.testnet/SetStatus</code></a></p>
<p>Here is where raen really raen really shines.</p>
<p>The method's documentation and the types documentation are available.  You can think of this as interactive documentation.</p>
<h2 id="getting-status"><a class="header" href="#getting-status">Getting Status</a></h2>
<p>Next since we are using <code>AccountId</code> the type is available to the form. Meaning the the form can validate an account id before submitting it, preventing the call from failing on the NEAR node:</p>
<p><a href="https://raen.dev/admin/#/advanced.statusmessage.raendev.testnet/SetStatus"><code>raen.dev/admin/#/advanced.statusmessage.raendev.testnet/SetStatus</code></a></p>
<p>You will also notice that now we don't get a string but a JSON object.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
